## 클로저(closure)
- 내부함수가 외부함수의 맥락(context)에 접근할 수 있는 것

### 내부함수
- 자바스크립트는 함수 안에서 또 다른 함수를 선언할 수 있음
```
function outter(){
  function inner(){
    var title = 'coding everybody'; 
    alert(title);  // coding everybody 
  }
  inner();
}
outter();
```
> function inner(){} 는 var inner = function(){}; 와 같음. 즉, 외부함수의 지역변수 역할로 이 함수 안에서만 사용 될 함수인 것

> 함수 outter의 안에 함수 inner가 정의 되어 있음. 함수 inner를 내부 함수라고 함

```
function outter(){
  var title = 'coding everybody';
  function inner(){
    alert(title);  // coding everybody 
  }
  inner();
}
outter();
```
> 내부함수 inner에서 title을 호출했을 때, 외부함수인 outter의 지역변수인 title에 접근할 수 있음 = 클로저


### 클로저란?
- 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근할 수 있는 메커니즘
```
function outter(){
  var title = 'coding everybody';  
  return function(){
    alert(title);  // coding everybody
  }
}
var inner = outter();
inner();
```
> 함수 outter();를 호출하는데 그 결과가 변수 inner에 담김. return은 한번 실행 후 종료되기때문에 여기에서 외부함수는 종료.<br/>그리고 실행이 inner();로 넘어오면 outter 함수는 실행이 끝났기 때문에 이 함수의 지역변수는 소멸됨<br/>그런데 함수 inner();를 실행했을 때 coding everybody가 출력된다는 것은 외부함수의 지역변수 title이 소멸되지 않았다는 것을 의미함<br/>inner();를 통해 내부함수를 다시 호출함으로써 이미 종료된 외부함수의 title에 접근해 값을 가져옴. 즉, 소멸된 후에도 호출이 가능함

> 결국, 클로저란 내부함수가 외부함수의 지역변수에 접근 할 수 있으며 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는 특성을 의미함

## Private variable(비밀변수)
-  소프트웨어가 커지는 과정에서 제공된 어떠한 정보를 아무나 수정하는것을 방지하는 것
```
function factory_movie(title){
  return {
    get_title : function (){
      return title;
    },
    set_title : function(_title){
      title = _title
    }
  }
}

ghost = factory_movie('Ghost in the shell');
matrix = factory_movie('Matrix');
 
alert(ghost.get_title());  // Ghost in the shell
alert(matrix.get_title());  // Matrix
 
ghost.set_title('공각기동대'); 
  
alert(ghost.get_title());  // 공각기동대
alert(matrix.get_title());  // Matrix
```

- __과정__
1. __`매개변수는 함수에서 지역변수로 사용`__ 되기 때문에 return title; 은 factory_movie(title){} 에서 title을 가져옴
2. function(_title) 은 title = _title의 _title이 되고 _title는 다시 title = _title의 title이 된다.
3. 이 title은 내부변수를 가르키기 때문에 factory_movie(title)의 title이 됨
4. ghost와 matrix는 똑같은 객체이지만 객체가 가진 get_title 메소드가 접근하는 title이라는 지역변수의 값은 다르기 때문에 결과가 다르게 출력된다.5. ghost.set_title('공각기동대');에서 지역변수를 수정한다. 단, ghost 객체가 접근할수있는 title의 값만을 수정하기때문에 matrix 객체가 접근하는 것에는 영향을 미치지 않음

- __해설__
1. 클로저는 객체의 메소드에서도 사용할 수 있다. 위의 예제는 함수의 리턴값으로 객체를 반환하고 있다. 이 객체는 메소드 get_title과 set_title을 가지고 있다. 이 메소드들은 외부함수인 factory_movie의 인자값으로 전달된 지역변수 title을 사용하고 있다.
2. 동일한 외부함수 안에서 만들어진 내부함수나 메소드는 외부함수의 지역변수를 공유한다. ghost.set_title('공각기동대');에서 실행 된 set_title은 외부함수 factory_movie의 지역변수 title의 값을 '공각기동대'로 변경했다. alert(ghost.get_title()); 에서 ghost.get_title();의 값이 '공각기동대'인 것은 set_title와 get_title 함수가 title의 값을 공유하고 있다는 의미다.
3. 그런데 똑같은 외부함수 factory_movie를 공유하고 있는 ghost와 matrix의 get_title의 결과는 서로 각각 다르다. 그것은 외부함수가 실행될 때마다 새로운 지역변수를 포함하는 클로저가 생성되기 때문에 ghost와 matrix는 서로 완전히 독립된 객체가 된다.
4. factory_movie의 지역변수 title은 객체 return{}에서 정의된 _객체의 메소드_에서만 접근 할 수 있는 값이다. 이 말은 title의 값을 읽고 수정 할 수 있는 것은 factory_movie 메소드를 통해서 만들어진 객체 뿐이라는 의미다. JavaScript는 기본적으로 Private한 속성을 지원하지 않는데, 클로저의 이러한 특성을 이용해서 Private한 속성을 사용할 수 있게된다.

- __정리__ <br />
여기에서의 비밀함수는 title이다. function factory_movie()는 return을 해줌으로써 수명이 끝나서 그 지역변수인 title은 factory_movie의 내부함수인 get_title과 set_title을 통해서만 접근할수있는 비밀변수가 되었다.

- __장점__ <br />
title의 정보에 접근할수 있는 채널은 get_title과 set_title만이 접근가능하다. 그래서 title 변수의 값을 외부에서 어떠한 의미로 사용하던간에 그 안에 get_title과 set_title의 맥락은 영향을 미치지않는다. 그리고 공각기동대처럼 title을 수정하더라도 if문으로 조건을 줄수있다.
```
set_title : function(_title){
  if (typeof _title === 'string') {
    title = _title	
  } else {
    alert('제목은 문자열이어야 합니다')
  }			
}

ghost.set_title('공각기동대');  // 공각기동대
ghost.set_title('1');  // 제목은 문자열이어야 합니다
```
> title을 꽁꽁 묶어두고 변수를 set_title을 통해서만 변경할수있고 그 변수의 값을 가져올때는 get_title을 통해서만 가져올 수 있도록 하면 데이터는 더 안전하게 저장되고 안전하게 수정될 수 있다.

- __참고__ <br />
Private 속성은 객체의 외부에서는 접근 할 수 없는 외부에 감춰진 속성이나 메소드를 의미한다. 이를 통해서 객체의 내부에서만 사용해야 하는 값이 노출됨으로서 생길 수 있는 오류를 줄일 수 있다. 자바와 같은 언어에서는 이러한 특성을 언어 문법 차원에서 지원하고 있다.
